# 101.2 راه‌اندازی سیستم (Boot)

**وزن:** 3  
**توضیح:** داوطلبان باید قادر به راهنمایی سیستم در طول فرآیند راه‌اندازی باشند.

## حوزه‌های کلیدی دانش
- ارائه دستورات رایج به بوت‌لودر و گزینه‌ها به کرنل در زمان راه‌اندازی
- نمایش دانش از توالی راه‌اندازی از BIOS/UEFI تا تکمیل راه‌اندازی
- درک SysVinit و systemd
- آگاهی از Upstart
- بررسی رویدادهای راه‌اندازی در فایل‌های لاگ

## اصطلاحات
- dmesg
- journalctl
- BIOS
- UEFI
- bootloader
- kernel
- initramfs
- init
- SysVinit
- systemd

## فرآیند راه‌اندازی (Boot Process)

درک این موضوع مهم است زیرا در این مرحله، کنترل بسیار کمی بر سیستم دارید و نمی‌توانید دستوراتی برای عیب‌یابی صادر کنید. باید درک خوبی از آنچه در حال رخ دادن است داشته باشید.

1. **Firmware مادربورد** یک PowerOnSelfTest (POST) انجام می‌دهد
2. **مادربورد** bootloader را بارگذاری می‌کند
3. **Bootloader** کرنل Linux را بر اساس پیکربندی‌ها/دستورات خود بارگذاری می‌کند
4. **کرنل** بارگذاری شده و سیستم (فایل‌سیستم ریشه) را آماده کرده و برنامه initialization را اجرا می‌کند
5. **برنامه Init** سرویس‌هایی مانند وب سرور، رابط گرافیکی، شبکه و غیره را راه‌اندازی می‌کند

همانطور که در بخش قبلی (101.1) بحث کردیم، Firmware روی مادربورد می‌تواند BIOS یا UEFI باشد.

### BIOS

**Basic Input Output System**
- قدیمی‌تر
- محدود به یک سکتور از دیسک و نیاز به bootloader چند مرحله‌ای دارد
- می‌تواند bootloader را از HDD داخلی/خارجی، CD/DVD، فلش USB، سرور شبکه راه‌اندازی کند
- اگر از HDD راه‌اندازی شود، Master Boot Record استفاده خواهد شد (1 سکتور)

### UEFI

**Unified Extensible Firmware Interface**
- مدرن و پیشرفته
- یک پارتیشن دیسک ویژه برای bootloader مشخص می‌کند. به نام EFI System Partition (ESP)
- ESP به فرمت FAT است و در `/boot/efi` mount می‌شود و فایل‌های bootloader پسوند `.efi` دارند
- می‌توانید `/sys/firmware/efi` را بررسی کنید تا ببینید آیا از سیستم UEFI استفاده می‌کنید یا نه

## Bootloader

Bootloader حداقل سخت‌افزار لازم برای راه‌اندازی سیستم را مقداردهی اولیه می‌کند. سپس، سیستم‌عامل را پیدا کرده و اجرا می‌کند.

از نظر فنی می‌توانید UEFI خود را به اجرای هر چیزی که می‌خواهید اشاره دهید، اما معمولاً تحت سیستم‌های GNU/Linux، از GRUB استفاده می‌کنیم. GRUB می‌تواند برای اجرای هر برنامه خاصی که نیاز دارید استفاده شود، اما معمولاً سیستم‌عامل را اجرا می‌کند.

## Kernel (کرنل)

کرنل هسته سیستم‌عامل شماست. اساساً خود LINUX است. bootloader شما کرنل را در حافظه بارگذاری کرده و آن را اجرا می‌کند. اما کرنل برای شروع به برخی اطلاعات اولیه نیاز دارد؛ چیزهایی مانند درایورهایی که برای کار با سخت‌افزار ضروری هستند. آنها در `initrd` یا `initramfs` در کنار کرنل ذخیره شده و در طول راه‌اندازی استفاده می‌شوند.

همچنین می‌توانید با استفاده از پیکربندی‌های Grub، پارامترها را به کرنل در طول راه‌اندازی ارسال کنید. به عنوان مثال، ارسال 1 یا S منجر به راه‌اندازی سیستم در حالت single-user (بازیابی) می‌شود. یا می‌توانید گرافیک خود را مجبور کنید در حالت 1024×768x24 کار کند با ارسال `vga=792` به کرنل در طول راه‌اندازی.

## dmesg

Linux لاگ‌های فرآیند راه‌اندازی را در طول راه‌اندازی به شما نشان می‌دهد. برخی از سیستم‌های دسکتاپ این را پشت یک صفحه splash زیبا پنهان می‌کنند که می‌توانید با استفاده از کلید `Esc` یا فشار دادن `Ctrl+Alt+F1` آن را پنهان کنید.

به دلایل متعددی که خارج از محدوده این دوره است، کرنل لاگ‌های خود را در "Kernel Ring Buffer" ذخیره می‌کند. پس از تکمیل فرآیند راه‌اندازی، دیمون syslog **لاگ‌های راه‌اندازی** را جمع‌آوری کرده و در `/var/log/dmesg` ذخیره می‌کند.

برای مشاهده همه لاگ‌ها از جمله آنچه پس از فرآیند راه‌اندازی لاگ شده از دستور `dmesg` استفاده می‌کنیم.

همچنین می‌توانیم از `journalctl -k` برای بررسی لاگ‌های کرنل یا از `journalctl -b` برای بررسی لاگ‌های راه‌اندازی استفاده کنیم (یا حتی از `journalctl -u kernel` برای دیدن همه لاگ‌های قبلی نیز استفاده کنیم).

علاوه بر اینها، بیشتر سیستم‌ها لاگ‌های راه‌اندازی را در یک فایل متنی نیز نگه می‌دارند و می‌توان آنها را به ترتیب در `/var/log/boot` یا `/var/log/boot.log` در سیستم‌های مبتنی بر Debian یا Red-Hat پیدا کرد.

### /var/log/messages

پس از راه‌اندازی فرآیند init، دیمون syslog پیام‌ها را لاگ خواهد کرد. این فایل دارای timestamps است و در طول راه‌اندازی مجدد ماندگار می‌شود.

کرنل هنوز در حال لاگ کردن پیام‌های خود در Kernel Buffer Ring است.

در برخی سیستم‌ها، ممکن است `/var/log/syslog` نامیده شود.

لاگ‌های بسیار دیگری در `/var/log` وجود دارد.

## init

وقتی مقداردهی اولیه کرنل به پایان رسید، زمان شروع برنامه‌های دیگر است. برای انجام این کار، کرنل فرآیند Initialization Daemon را اجرا می‌کند و آن مراقبت از شروع دیمون‌ها، سرویس‌ها، زیرسیستم‌ها و برنامه‌های دیگر را بر عهده می‌گیرد. با استفاده از سیستم init می‌توان گفت "به سرویس A و سپس سرویس B نیاز دارم. سپس به C و D و E نیاز دارم اما D را شروع نکن مگر اینکه A و B در حال اجرا باشند". مدیر سیستم می‌تواند از سیستم init برای توقف و شروع سرویس‌ها بعداً استفاده کند.

سیستم‌های init مختلفی وجود دارد:

### SysVinit

بر اساس Unix System V است. دیگر زیاد استفاده نمی‌شود اما مردم آن را دوست داشتند زیرا از اصول Unix پیروی می‌کرد. ممکن است آن را روی ماشین‌های قدیمی‌تر یا حتی روی ماشین‌های نصب شده اخیر ببینید.

### upstart

یک جایگزین مبتنی بر رویداد برای دیمون init سنتی توسعه یافته توسط Canonical (افراد پشت Ubuntu) بود. هدف پروژه ساخت جایگزینی برای SysV بود که در سال 2007 منتشر شد. در نهایت، پروژه به دلیل پذیرش گسترده Systemd متوقف شد. حتی Ubuntu این روزها از Systemd استفاده می‌کند، اما upstart هنوز در ChromeOS گوگل یافت می‌شود.

### Systemd

جایگزین جدید است. توسط نخبگان Linux به دلیل عدم پیروی از اصول Unix متنفر است اما به طور گسترده توسط توزیع‌های اصلی پذیرفته شده است. می‌تواند سرویس‌ها را به صورت موازی شروع کند و کارهای زیاد جالبی انجام دهد!

فرآیند init شناسه 1 را دارد و می‌توانید آن را با اجرای موارد زیر پیدا کنید:

```bash
# which init
/sbin/init
# readlink -f /sbin/init
/usr/lib/systemd/systemd
# ps -p 1
PID TTY TIME     CMD
1   ?   00:00:06 systemd
```

می‌توانید سلسله مراتب فرآیندها را با استفاده از دستور `pstree` بررسی کنید.

### systemd

جدید است، دوست داشته شده و منفور. ایده‌های جدید زیادی دارد اما برخی از اصول محبوب UNIX را دنبال نمی‌کند (مثلاً ذخیره نکردن لاگ‌ها در یک فایل متنی یا تلاش برای کمک بیش از حد اما درخواست رمز عبور root وقتی دستورات را با sudo اجرا نمی‌کنید). به ما اجازه می‌دهد سرویس‌ها را اگر سخت‌افزار متصل باشد، در فواصل زمانی، اگر سرویس دیگری شروع شده باشد و... اجرا کنیم.

systemd حول **units** ساخته شده است. یک unit می‌تواند یک سرویس، گروهی از سرویس‌ها یا یک عمل باشد. unit ها دارای یک نام، یک نوع و یک فایل پیکربندی هستند. 12 نوع unit وجود دارد: automount، device، mount، path، scope، service، slice، snapshot، socket، swap، target و timer.

از `systemctl` برای کار با این unit ها و `journalctl` برای دیدن لاگ‌ها استفاده می‌کنیم:

```bash
# systemctl list-units
# systemctl list-units --type=target
# systemctl get-default
# default target (groups of services are started via target unit files)
```

unit ها را می‌توان در این مکان‌ها پیدا کرد (مرتب شده بر اساس اولویت):
- `/etc/systemd/system/`
- `/run/systemd/system/`
- `/usr/lib/systemd/system`

```bash
# systemctl list-unit-files
# systemctl cat ntpd.service
# systemctl cat graphical.target
```

می‌توانیم از این دستورات برای کار با سرویس‌ها استفاده کنیم:

```bash
# systemctl stop sshd
# systemctl start sshd
# systemctl status sshd
# systemctl is-active sshd
# systemctl is-failed sshd
# systemctl restart sshd
# systemctl reload sshd # re-reads the configuration of the service configs
# systemctl daemon-reload sshd # re-reads the configuration of the systemd configs
# systemctl enable sshd
# systemctl disable sshd
```

دستورات دیگری نیز وجود دارد:

```bash
# systemctl is-system-running # running, degraded, maintenance, initializing, starting, stopping
# systemctl --failed
```

برای بررسی لاگ‌ها، باید از ابزار `journalctl` استفاده کنیم:

```bash
# journalctl # show all journal
# journalctl --no-pager # do not use less
# journalctl -n 10 # only 10 lines
# journalctl -S -1d # last 1 day
# journalctl -xe # last few logs
# journalctl -u ntp # only ntp unit
# journalctl _PID=1234
```

### SysV

سیستم init قدیمی‌تر است. هنوز می‌تواند در بسیاری از سیستم‌ها استفاده شود. فایل‌های کنترل در `/etc/init.d/` قرار دارند و به اسکریپت‌های bash عمومی نزدیک‌تر هستند. در بسیاری از موارد می‌توانید مانند این فراخوانی کنید:

```bash
/etc/init.d/ntpd status
/etc/init.d/ntpd stop
/etc/init.d/ntpd start
/etc/init.d/ntpd restart
```

در مورد runlevel ها بیشتر در 101.3 صحبت خواهیم کرد.

---

**مثال عملی:** برای بررسی لاگ‌های راه‌اندازی آخرین بار:
```bash
journalctl -b -1
```

برای بررسی وضعیت یک سرویس:
```bash
systemctl status NetworkManager
```

**خلاصه:** فرآیند راه‌اندازی Linux شامل POST، بارگذاری bootloader، بارگذاری kernel، و اجرای init است. BIOS قدیمی است و از MBR استفاده می‌کند، در حالی که UEFI مدرن است و از ESP استفاده می‌کند. لاگ‌های راه‌اندازی در `dmesg` و `/var/log/` ذخیره می‌شوند. سیستم‌های init شامل SysVinit (قدیمی)، Upstart (منسوخ) و Systemd (مدرن و رایج) هستند. از `systemctl` برای مدیریت سرویس‌ها و `journalctl` برای مشاهده لاگ‌ها استفاده می‌شود.

---

← 101.1 تعیین و پیکربندی تنظیمات سخت‌افزار  
**فهرست فصل‌ها**  
101.3 تغییر runlevel ها / اهداف راه‌اندازی و خاموش یا راه‌اندازی مجدد سیستم →

**دسته‌بندی:** LPIC1  
**برچسب‌ها:** LPIC1، LPIC1-101-500، System Architecture  
**تماس**
