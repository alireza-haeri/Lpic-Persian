# 103.5 - ایجاد، نظارت و پایان دادن به فرآیندها

## اهداف یادگیری

در این فصل با موارد زیر آشنا می‌شوید:

- اجرای شغل‌ها در پیش‌زمینه و پس‌زمینه
- سیگنال دادن به برنامه برای ادامه اجرا پس از خروج
- نظارت بر فرآیندهای فعال
- انتخاب و مرتب‌سازی فرآیندها برای نمایش
- ارسال سیگنال‌ها به فرآیندها

## کلیدواژه‌ها

`&`, `bg`, `fg`, `jobs`, `kill`, `nohup`, `ps`, `top`, `free`, `uptime`, `killall`, `pgrep`, `pkill`, `watch`, `screen`, `tmux`

---

## مدیریت فرآیندها

### فرآیندها در پیش‌زمینه و پس‌زمینه

یکی از نقاط عالی لینوکس حتی از روزهای اولیه‌اش، توانایی اجرای برنامه‌های مختلف و شغل‌ها همزمان است. این کار با ارسال برنامه‌ها به پس‌زمینه انجام می‌شود.

معمولاً اگر برنامه‌ای را در ترمینال اجرا کنید، ترمینال شما را تا زمانی که اجرا می‌شود بلوکه می‌کند اما ارسال فرمان به پس‌زمینه این را جلوگیری می‌کند:

```bash
xeyes &
```

حتی وقتی برنامه‌ای معمولاً در پیش‌زمینه اجرا می‌شود، می‌توانید دو کار انجام دهید:

- شکستن آن با `Ctrl+c`
- تعلیق یا توقف آن با `Ctrl+z`

یک شغل متوقف شده می‌تواند با فرمان `fg` به پیش‌زمینه آورده شود (یا با `bg` به پس‌زمینه). همچنین می‌توانید همه شغل‌ها را با فرمان `jobs` لیست کنید.

```bash
$ xeyes
^Z
[1]+  Stopped                 xeyes
$ jobs
[1]+  Stopped                 xeyes
$ bg
[1]+ xeyes &
$ jobs
[1]+  Running                 xeyes &
$ sleep 1000 &
[2] 7395
$ jobs
[1]-  Running                 xeyes &
[2]+  Running                 sleep 1000 &
$ fg %2
sleep 1000
^Z
[2]+  Stopped                 sleep 1000
$ jobs
[1]-  Running                 xeyes &
[2]+  Stopped                 sleep 1000
$ bg sle
[2]+ sleep 1000 &
$ jobs
[1]-  Running                 xeyes &
[2]+  Running                 sleep 1000 &
```

### nohup

فرمان `nohup` به برنامه‌ها اجازه می‌دهد حتی پس از بستن ترمینال یا خروج اجرا شوند. به طور پیش‌فرض خروجی را به `nohup.out` می‌نویسد:

```bash
$ nohup ping 4.2.2.4
nohup: ignoring input and appending output to 'nohup.out'
^C$
cat nohup.out
PING 4.2.2.4 (4.2.2.4) 56(84) bytes of data.
64 bytes from 4.2.2.4: icmp_seq=1 ttl=51 time=225 ms
64 bytes from 4.2.2.4: icmp_seq=3 ttl=51 time=223 ms
--- 4.2.2.4 ping statistics ---
4 packets transmitted, 2 received, 50% packet loss, time 3010ms
rtt min/avg/max/mdev = 223.584/224.767/225.950/1.183 ms
```

معمولاً از `2>` برای هدایت خطاهای nohup به فایل دیگری و از `&` برای اجرای در پس‌زمینه استفاده می‌شود:

```bash
nohup script.sh > mynohup.out 2>&1 &
```

### kill

با وجود نام ترسناکش، فرمان `kill` سیگنال‌های یونیکس را به فرآیندها ارسال می‌کند. فشردن `Ctrl+c` و `Ctrl+z` نیز سیگنال ارسال می‌کنند. به طور پیش‌فرض، فرمان `kill` سیگنال 15 (TERM) را ارسال می‌کند که به فرآیند می‌گوید خود را پایان دهد.

```bash
$ jobs
[3]   Running                 xeyes &
[4]   Running                 sleep 1000 &
[5]-  Running                 sleep 2000 &
[6]+  Running                 sleep 3000 &
$ kill %4
$ jobs
[3]   Running                 xeyes &
[4]   Terminated              sleep 1000
[5]-  Running                 sleep 2000 &
[6]+  Running                 sleep 3000 &
$ jobs
[3]   Running                 xeyes &
[5]-  Running                 sleep 2000 &
[6]+  Running                 sleep 3000 &
```

همچنین امکان استفاده از PID به جای شماره شغل و ارسال سیگنال‌های دیگر وجود دارد. فرمت عمومی `kill -SIGNAL_ID_OR_NAME process_id` است:

| شماره سیگنال | نام سیگنال | معنی |
|-------------|-----------|------|
| 1 | HUP | اطلاع به فرآیند که ترمینال کنترل‌کننده‌اش (مانند اتصال ssh) پایان یافته |
| 15 | TERM | درخواست پایان نرم |
| 9 | KILL | پایان اجباری فرآیند |

بنابراین می‌توانید `kill -9 8733` را برای پایان اجباری فرآیند ID 8733 انجام دهید.

به یاد داشته باشید فرمان `nohup` :) به معنای "پاسخ به سیگنال hup نده" است.

### killall

این فرمان سیگنال داده شده (یا به طور پیش‌فرض 15) را به همه فرآیندهای دارای نام داده شده ارسال می‌کند:

```bash
$ jobs
[3]   Running                 xeyes &
[5]-  Running                 sleep 2000 &
[6]+  Running                 sleep 3000 &
$ ps -ef | grep sleep
jadi       7864     7651  0 21:07 pts/1    00:00:00 sleep 2000
jadi       7865     7651  0 21:07 pts/1    00:00:00 sleep 3000
jadi       7977     7651  0 21:14 pts/1    00:00:00 grep sleep
$ killall sleep
[5]-  Terminated              sleep 2000
[6]+  Terminated              sleep 3000
$ jobs
[3]+  Running                 xeyes &
$ ps -ef | grep sleep
jadi       7980     7651  0 21:14 pts/1    00:00:00 grep sleep
```

### pkill

سیگنال داده شده (یا 15) را به همه فرآیندهای دارای الگوی خاص در نام‌شان ارسال می‌کند:

```bash
$ jobs
[3]   Running                 xeyes &
[5]-  Running                 sleep 2000 &
[6]+  Running                 sleep 3000 &
$ ps -ef | grep sleep
jadi       7864     7651  0 21:07 pts/1    00:00:00 sleep 2000
jadi       7865     7651  0 21:07 pts/1    00:00:00 sleep 3000
jadi       7977     7651  0 21:14 pts/1    00:00:00 grep sleep
$ pkill sle
[5]-  Terminated              sleep 2000
[6]+  Terminated              sleep 3000
$ jobs
[3]+  Running                 xeyes &
$ ps -ef | grep sleep
jadi       7980     7651  0 21:14 pts/1    00:00:00 grep sleep
```

## نظارت بر فرآیندها

### ps

فرمان `ps` فرآیندهای در حال اجرا روی کامپیوتر شما را نشان می‌دهد. هر فرآیند یک ID فرآیند (PID) و یک ID فرآیند والد (PPID) دارد.

```bash
$ sleep 1000 &
[1] 7678
$ sleep 1001 &
[2] 7679
$ xeyes &
[3] 7680
$ ps
PID TTY          TIME CMD
7651 pts/1    00:00:00 bash
7678 pts/1    00:00:00 sleep
7679 pts/1    00:00:00 sleep
7680 pts/1    00:00:00 xeyes
7681 pts/1    00:00:00 ps
```

دو ترکیب سوئیچ رایج `ps aux` (یا `-aux`) و `ps ef` است که همه فرآیندها روی سیستم را نشان می‌دهد:

```bash
$ ps -aux | wc -l
293
```

همچنین امکان استفاده از سوئیچ `--sort` برای مرتب‌سازی خروجی بر اساس فیلدهای مختلف وجود دارد (+ برای صعودی & - برای نزولی).

```bash
$ ps -af --sort +comm,-sid
UID        PID  PPID  C STIME TTY      TIME CMD
root      5486  5478  0 19:59 pts/12   00:00:00 -su
root      4444  1169  0 19:56 tty4     00:00:00 -bash
jadi      6638  5412  0 20:10 pts/0    00:04:43 node /usr/local/bin/sslocal
jadi      7778  7651  0 20:58 pts/1    00:00:00 ps -af --sort +comm,-sid
jadi      7678  7651  0 20:48 pts/1    00:00:00 sleep 1000
jadi      7679  7651  0 20:48 pts/1    00:00:00 sleep 1001
jadi      7775  7651  0 20:58 pts/1    00:00:00 sleep 1000
jadi      7776  7651  0 20:58 pts/1    00:00:00 sleep 1000
jadi      7777  7651  0 20:58 pts/1    00:00:00 sleep 1000
root      5478  5477  0 19:59 pts/12   00:00:00 su -
root      5477  5008  0 19:59 pts/12   00:00:00 sudo su -
jadi      7680  7651  0 20:48 pts/1    00:01:01 xeyes
```

### pgrep

شما دیده‌اید که `ps -ef` فرآیندها از همه کاربران را نشان می‌دهد. می‌توانیم روی آن grep کنیم و ببینیم چه کسی `gedit` را اجرا می‌کند و ID فرآیندش چیست:

```bash
$ ps -ef | grep gedit
jadi      6213  4604  9 20:06 ?        00:04:43 gedit
jadi      7725  7651  0 20:55 pts/1    00:00:00 grep gedit
```

اما راه مستقیم‌تری برای بررسی PID همه فرآیندهای gedit وجود دارد:

```bash
$ pgrep gedit
6213
```

### top

این رایج‌ترین ابزار برای نظارت ساده روی سیستم است. وضعیت را به‌روزرسانی می‌کند و نگاهی خوب به وضعیت می‌دهد:

```bash
$ top
top - 21:00:44 up 1:16,  5 users,  load average: 1.51, 1.65, 1.78
Tasks: 293 total,   1 running, 292 sleeping,   0 stopped,   0 zombie
%Cpu(s): 19.0 us,  5.0 sy,  0.0 ni, 70.9 id,  5.1 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  8060264 total,  5359812 used, 2700452 free,  169240 buffers
KiB Swap:  7811068 total,        0 used, 7811068 free. 2250692 cached Mem
PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM    TIME+ COMMAND
6570 jadi      20   0 1437752 546064 88312 S  18.4  6.8  12:00.96 firefox
4870 jadi      20   0 1762516 299120 75664 S  12.2  3.7   7:37.05 compiz
4492 root       9 -11  455152  11516  8940 S   6.1  0.1   1:06.81 pulseaudio
4532 root      20   0  389028  77116 60192 S   6.1  1.0  12:16.63 Xorg
4723 jadi      20   0  358936  8288  5512 S   6.1  0.1   9:51.52 ibus-daemon
5648 jadi      20   0 1641556 203676 102840 S   6.1  2.5   3:20.88 chrome
7082 jadi      20   0 1210748 73136 42528 S   6.1  0.9   0:36.51 Telegram
7806 jadi      20   0   33796  3004  2500 R   6.1  0.0   0:00.02 top
1 root      20   0   29528  4320  2584 S   0.0  0.1   0:01.71 init
```

می‌توانید فرآیندها، بار سیستم، uptime، وضعیت CPU، حافظه، ... را ببینید و برخی کارها انجام دهید:

| کلید در top | عملکرد |
|-------------|---------|
| h | کمک |
| q | خروج |
| M | مرتب‌سازی بر اساس استفاده از حافظه |
| c | نمایش فرمان‌های کامل |
| k | پایان دادن پس از پرسیدن pid و سیگنال |

### free

فرمان `free` اطلاعات مربوط به حافظه سیستم را نشان می‌دهد. پیش‌فرض کیلوبایت است اما می‌توانید با `-m` برای مگابایت، `-g` برای گیگابایت یا حتی `-b` برای بایت تغییر دهید. همچنین می‌توانید از `-h` برای قابل خواندن توسط انسان استفاده کنید.

```bash
$ free -m
total       used       free     shared    buffers     cached
Mem:          7871       5231       2640        332        169       2195
-/+ buffers/cache:       2866       5005
Swap:         7627          0       7627
```

!!! note "نکته عمومی"
    اگر سیستم شما از Swap استفاده می‌کند، مشکلات حافظه دارید.

### uptime

فرمان `uptime` زمان، uptime سیستم (چقدر سیستم اجرا شده)، چند کاربر وارد شده‌اند و میانگین بار 1، 5 & 15 دقیقه را نشان می‌دهد:

```bash
$ uptime
21:18:52 up 1:34,  5 users,  load average: 2.38, 2.64, 2.41
```

اگرچه یکی از مهم‌ترین KPIهای وضعیت سیستم است، برخی از مدیران لینوکس با تجربه نمی‌دانند میانگین بار چیست. میانگین بار نشان می‌دهد چند فرآیند در صف "برای اجرا" هستند. اگر این عدد بالاتر از تعداد هسته‌های CPU شما باشد، در وضعیت بدی هستید. اگر نزدیک به تعداد هسته‌های شما باشد، کمی خطرناک است، و اگر کمتر از 1/10 تعداد هسته‌های شما باشد، سیستم شما کمی بی‌کار است. به یاد داشته باشید چگونه تعداد هسته‌های خود را چک کنید؟ در `/proc/cpuinfo` است یا `nproc`.

### watch

گاهی اوقات فرمانی دارید که خروجی نشان می‌دهد اما می‌خواهید آن را ادامه دهید و خروجی را مشاهده کنید. در این موارد، `watch` دوست شماست. به شما اجازه می‌دهد خروجی فرمان را در بازه‌های زمانی خاص اجرا و چک کنید (پیش‌فرض 2 ثانیه).

```bash
$ watch free -h
```

اگر لوله در فرمان شما دارید، باید فرمان watched را در double-quote یا single-quote قرار دهید:

```bash
$ watch "ls -ltrh | wc -l"
```

برخی سوئیچ‌ها:

- `-n` برای مشخص کردن بازه در ثانیه
- `-b` بوق اگر فرمان خروج غیرصفر داشته باشد
- `-d` تفاوت‌ها بین اجرا‌ها را نشان می‌دهد

## مولتی‌پلکسرهای ترمینال

### screen

اگر به سیستم‌های مبتنی بر GUI عادت دارید، آسان است که ترمینال‌های مختلف را کنار هم اجرا کنید و از آنها استفاده کنید. اما اگر روی سرور هستید، نیاز به ابزارهای دیگر برای مولتی‌پلکس کردن ترمینال خود دارید. یکی از این فرمان‌ها `screen` است.

با `screen` اجرا کنید و enter را فشار دهید تا از پنجره خوش‌آمدگویی خارج شوید و به prompt بروید. می‌توانید از آن به عنوان ترمینال عادی استفاده کنید و از آن جدا شوید (و بگذارید در پس‌زمینه اجرا شود) با کلیدهای `Ctrl + A` و سپس `D`. لیست screenهای خود را با `screen -ls` چک کنید و به هر کدام با `screen -r screen-id` متصل شوید.

در زیر چند سوئیچ رایج، همه باید پس از ترکیب `Ctrl + A` صادر شوند.

| کلید | استفاده |
|------|---------|
| \\ | همه فرآیندهای پنجره‌ها را بکش و ترمینال را پایان بده |
| \| | پنجره فعلی را به دو فوکوس عمودی تقسیم کن |
| Shift+S | پنجره فعلی را به دو فوکوس افقی تقسیم کن |
| C | پنجره‌ای در فوکوس فعلی ایجاد کن |
| Tab | به فوکوس بعدی برو |
| D | از پنجره جدا شو |
| K | پنجره فعلی را بکش |
| N | به پنجره بعدی حرکت کن |
| P | به پنجره قبلی حرکت کن |

نقطه عالی درباره screen (و tmux) این است که حتی پس از خروج از سیستم اجرا می‌ماند و امکان اتصال مجدد به همان screen (یا tmux) وجود دارد.

### tmux

مانند screen روی استروئیدها! در اکثر توزیع‌ها به طور پیش‌فرض نصب نیست و باید ابتدا نصب کنید. پیشوند فرمان پیش‌فرض `Ctrl+B` است و پس از اجرای `tmux new` می‌توانید صادر کنید:

| کلید | استفاده |
|------|---------|
| % | پنجره فعلی را عمودی تقسیم کن |
| " | پنجره فعلی را افقی تقسیم کن |
| D | از پنجره فعلی جدا شو |
| & | پنجره فعلی را بکش |

می‌توانید sessionهای tmux را با `tmux ls` لیست کنید و به یکی با `tmux att` متصل شوید تا به آخرین متصل شوید یا `tmux att -t session_name` برای اتصال به یک خاص.

ابزارهایی مانند `tmux` می‌توانند مفید باشند و در برخی موقعیت‌ها کارایی شما را افزایش دهند. برای یادگیری بیشتر به مستندات رسمی یا منابع آموزشی معتبر مراجعه کنید.

## نکات

- استفاده از `&` برای اجرای در پس‌زمینه
- `jobs` برای لیست کردن شغل‌های پس‌زمینه
- `fg` و `bg` برای کنترل شغل‌ها
- `nohup` برای اجرای پس از خروج
- سیگنال‌های مختلف در `kill`
- `killall` و `pkill` برای پایان دادن گروهی
- ابزارهای نظارت: `ps`, `top`, `free`, `uptime`, `watch`
- مولتی‌پلکسرها: `screen` و `tmux`

## تمرین‌ها

1. یک برنامه را در پس‌زمینه اجرا کنید و سپس آن را به پیش‌زمینه بیاورید.
2. از `nohup` برای اجرای یک فرمان پس از خروج استفاده کنید.
3. فرآیندها را با `ps` لیست کنید و یکی را با `kill` پایان دهید.
4. از `top` برای نظارت بر سیستم استفاده کنید.
5. از `watch` برای نظارت بر خروجی یک فرمان استفاده کنید.
6. یک session `screen` ایجاد کنید و از آن جدا شوید و دوباره متصل شوید.

## خلاصه

در این فصل با مدیریت فرآیندها در لینوکس آشنا شدیم. یاد گرفتیم چگونه فرآیندها را در پیش‌زمینه و پس‌زمینه اجرا کنیم، سیگنال‌ها را ارسال کنیم و فرآیندها را نظارت کنیم. ابزارهایی مانند `ps`, `top`, `kill`, `nohup` و مولتی‌پلکسرهای ترمینال مانند `screen` و `tmux` را بررسی کردیم. این مهارت‌ها برای مدیریت سیستم‌های لینوکس ضروری هستند.
 
 