# 105.1 شخصی‌سازی و استفاده از محیط shell

**وزن:** 4  
**توضیح:** داوطلبان باید قادر به شخصی‌سازی محیط‌های shell برای برآورده کردن نیازهای کاربران باشند. داوطلبان باید قادر به تغییر پروفایل‌های سراسری و کاربر باشند.

## حوزه‌های کلیدی دانش
- تنظیم متغیرهای محیطی (مانند PATH) در زمان ورود یا هنگام ایجاد shell جدید
- نوشتن توابع Bash برای دنباله‌های دستورات پرکاربرد
- نگهداری دایرکتوری‌های الگو (skeleton) برای حساب‌های کاربری جدید
- تنظیم مسیر جستجوی دستورات با دایرکتوری مناسب

## اصطلاحات
- .
- source
- /etc/bash.bashrc
- /etc/profile
- env
- export
- set
- unset
- ~/.bash_profile
- ~/.bash_login
- ~/.profile
- ~/.bashrc
- ~/.bash_logout
- function
- alias

## متغیرهای محیطی (Environment variables)

متغیرهای محیطی Shell متغیرهای ویژه‌ای هستند که حاوی اطلاعات و پیکربندی درباره shell هستند. سیستم shell از آنها استفاده می‌کند وقتی نیاز دارد یک prompt به شما نشان دهد، یک دستور را اجرا کند، یا جستجو کند که چه چیزی را اجرا کند. توزیع‌های مختلف سیستم‌عامل متغیرهای محیطی متفاوتی دارند و می‌توانید اگر نیاز دارید یا می‌خواهید، متغیرهای خود را اضافه کنید!

### env

`env` می‌تواند متغیرها را تنظیم، حذف یا نمایش دهد یا حتی یک دستور را در یک محیط اصلاح شده اجرا کند.

**سینتکس:**
```bash
env [OPTION]... [NAME=VALUE]... [COMMAND [ARGS]...]
```

**گزینه‌ها:**
- `-u NAME` یا `--unset=NAME`: متغیر NAME را از محیط حذف کنید، اگر در محیط بود
- `-` یا `-i` یا `--ignore-environment`: با یک محیط خالی شروع کنید، محیط به ارث رسیده را نادیده بگیرید

همچنین می‌توانید از دستور عمومی‌تر `printenv` استفاده کنید.

### set

`set` به شما اجازه می‌دهد مقادیر گزینه‌های shell (متغیرها) را تغییر دهید یا نام‌ها و مقادیر متغیرهای shell را نمایش دهید.

با استفاده از `set` می‌توانیم پیکربندی کنیم که bash چگونه کار می‌کند. اینها چند نمونه هستند:

| سوییچ | نتیجه |
|-------|-------|
| `-b` | باعث می‌شود وضعیت کارهای پس‌زمینه خاتمه یافته بلافاصله گزارش شود، نه قبل از چاپ prompt اولیه بعدی |
| `-e` | در صورتی که یک pipeline، دستور، ... غیر صفر برگرداند، بازگشت |
| `-n` | دستورات را بخواند اما اجرا نکند؛ این ممکن است برای بررسی اسکریپت برای خطاهای نحوی استفاده شود. این گزینه توسط shell های تعاملی نادیده گرفته می‌شود |
| `-t` | پس از خواندن و اجرای یک دستور خارج شود |
| `-C` | از بازنویسی فایل‌های موجود با استفاده از '>'، '>&' و '<>' جلوگیری کند |

## تنظیم متغیرهای محیطی

متغیرهای محیطی Bash فقط می‌توانند حاوی حروف (a تا z یا A تا Z)، اعداد (0 تا 9) یا کاراکتر زیرخط `_` باشند و نمی‌توانند با اعداد شروع شوند. به طور سنتی از حروف بزرگ (UPPERCASE) در نام متغیرهای خود استفاده می‌کنیم.

برای تنظیم یک متغیر محیطی جدید به شرح زیر عمل کنید:

```bash
$ name=jadi
$ desc='A programmer who enjoys cycling and promotes freedom'
$ echo $name
jadi
$ echo $desc
A programmer who enjoys cycling and promotes freedom
```

**نکات:**
- نباید فاصله‌ای در اطراف `=` وجود داشته باشد
- از گیومه یا گیومه دوتایی استفاده کنید وقتی مقدار شما فاصله (یا کاراکترهای ویژه دیگر) در خود دارد
- فقط هنگام ارجاع به یک متغیر از علامت دلار استفاده کنید، نه هنگام تعریف آن

### unset

این دستور یک متغیر یا تابع را پاک می‌کند:

```bash
$ name=jadi
$ echo $name
jadi
$ unset name
$ echo $name

```

### export

هنگام تنظیم متغیرهای محیطی با یک `=` ساده، متغیر فقط در shell فعلی در دسترس است. بنابراین حتی اگر یک دستور جدید را از shell فعلی اجرا کنید، متغیر در آنجا معتبر نخواهد بود (زیرا از نظر فنی دستور جدید در یک sub-shell اجرا خواهد شد). اگر می‌خواهید متغیر شما در shell فعلی و همه sub-shell های آن معتبر باشد، باید آن را `export` کنید:

```bash
$ export name=jadi
$ echo $name
jadi
$ bash
$ echo $name
jadi
```

### . (و source)

بله فقط یک نقطه! این یک میانبر برای دستور bash source است. می‌توانید آن را در فایل‌هایی مانند `/etc/profile` پیدا کنید. فایل اجرایی در جلوی آن را به عنوان بخشی از محیط فعلی اجرا می‌کند (و نه در یک فرآیند فرعی).

**نکته:** اگر فقط یک فایل را اجرا کنید (بدون source یا نقطه)، bash یک فرزند ایجاد می‌کند، فایل اجرایی را در آنجا اجرا می‌کند و سپس آن را می‌بندد.

دستور `source` معمولاً زمانی استفاده می‌شود که می‌خواهید متغیرهای محیطی یا توابع جدید/به‌روز شده را از یک اسکریپت بارگذاری کنید.

## نام‌های مستعار (Aliases)

این راهی برای تعریف... خب... یک `alias` است. می‌توانید آنها را در `~/.bashrc` خود پیدا کنید:

```bash
alias ll='ls -alF'
alias la='ls -A'
alias l='ls -CF'
```

این راهی برای تعریف یک میانبر است و می‌توانید مال خود را اضافه کنید:

```bash
alias testnet='ping 4.2.2.4'
```

## توابع (functions)

مانند زبان‌های برنامه‌نویسی بزرگتر، Bash توابع دارد، اگرچه در یک پیاده‌سازی تا حدودی محدود. یک تابع یک زیربرنامه، یک بلوک کد است که مجموعه‌ای از عملیات را پیاده‌سازی می‌کند، یک "جعبه سیاه" که یک وظیفه مشخص را انجام می‌دهد. هر جا که کد تکراری وجود دارد، وقتی یک کار با تنها تغییرات جزئی در روش تکرار می‌شود، پس استفاده از یک تابع را در نظر بگیرید.

```bash
funnyls () {
ls -ltrh
echo "This is a funny ls"
}
```

## محیط‌های مختلف shell

shell (اینجا bash) می‌تواند به 3 روش مختلف شروع شود:

1. وقتی به shell **login** می‌کنید، مثلاً بعد از یک ssh یا وقتی پشت یک ترمینال می‌نشینید و وارد یک ماشین Linux می‌شوید. این یک جلسه login تعاملی است
2. وقتی یک ترمینال جدید باز می‌کنید (مثلاً از یک محیط GUI). این هم تعاملی است اما یک shell **login** نیست
3. وقتی یک shell **spawn** می‌شود که یک دستور را اجرا می‌کنید. بله.. از نظر فنی وقتی یک دستور جدید را از یک shell اجرا می‌کنید، یک sub-shell شروع می‌شود، دستورات را اجرا می‌کند و سپس به shell شما برمی‌گردد. این "non interactive" shell نامیده می‌شود

خواهیم دید که چگونه متغیرهای محیطی پیش‌فرض مختلف می‌توانند در هر یک از این حالت‌ها تنظیم شوند.

### Login shell

این زمانی است که کاربر و رمز خود را می‌دهید تا وارد shell شوید. در این مورد، این مراحل محیط shell شما را تعریف خواهند کرد:

1. `/etc/profile` اجرا می‌شود
2. یک خط در `/etc/profile` هر چیزی که در `/etc/profile.d/` است را اجرا می‌کند

اکنون پروفایل سراسری بارگذاری شده و سیستم به پروفایل‌های خاص کاربر خواهد رفت:

3.1. `/home/USERNAME/.bash_profile`  
3.2. `/home/USERNAME/.bash_login`  
3.3. `/home/USERNAME/.profile`

توجه کنید که فقط یکی از 3.1، 3.2 و 3.3 اجرا می‌شود. سیستم به دنبال `.bash_profile` می‌رود و اگر وجود نداشت `.bash_login` را امتحان می‌کند و اگر وجود نداشت سعی می‌کند `.profile` را اجرا کند. اگر هر یک از اینها وجود داشته باشد، سیستم بیشتر جستجو نمی‌کند. بنابراین اگر فقط 3.2 و 3.3 را دارید، فقط 3.2 اجرا می‌شود.

در پایان، سیستم بارگذاری می‌کند:

4. `/home/USERNAME/.bashrc`

معمولاً هر پیکربندی شخصی که می‌خواهید را به `~/.bashrc` اضافه خواهید کرد.

### Interactive (non-login) shell

اگر یک shell را در حالت تعاملی (non-login) از یک GUI یا در یک ترمینال دیگر اجرا کنید، فقط دو فایل محیط را مدیریت خواهند کرد:

- `/etc/bash.bashrc` (یا `/etc/bashrc` در برخی سیستم‌ها)
- `/home/USERNAME/.bashrc`

### Non Interactive Shell

فایل خاصی برای استفاده در این مورد وجود ندارد. در عوض `BASH_ENV` داریم. وقتی یک shell non-interactive جدید شروع می‌شود، به این متغیر نگاه می‌کند و اگر به یک فایل اشاره می‌کند، آن را اجرا می‌کند.

در بیشتر توزیع‌های Linux، این مقدار محیطی به طور پیش‌فرض تنظیم نشده است.

## چند فایل بیشتر

### /etc/skel

این دایرکتوری حاوی فایل‌هایی است که به عنوان یک الگوی شروع برای هر کاربر جدید استفاده خواهد شد.

### .bash_logout

این زمانی اجرا می‌شود که از یک login shell خارج می‌شوید. در بسیاری از توزیع‌ها فقط صفحه را پاک می‌کند تا شخص بعدی نتواند آنچه قبل از خروج شما انجام می‌دادید را ببیند.

---

**مثال عملی:** برای اضافه کردن یک متغیر سراسری به همه کاربران:
```bash
sudo echo "export MYVAR='some value'" >> /etc/profile.d/myvar.sh
```

برای اضافه کردن alias شخصی:
```bash
echo "alias ll='ls -lah'" >> ~/.bashrc
source ~/.bashrc
```

**خلاصه:** محیط shell با متغیرهای محیطی، alias ها و توابع شخصی‌سازی می‌شود. از `env` برای نمایش/تنظیم متغیرها، `export` برای متغیرهای سراسری، `alias` برای میانبرها و `function` برای توابع استفاده کنید. فایل‌های پیکربندی مختلف برای login shell (`/etc/profile`، `~/.bash_profile`) و non-login shell (`/etc/bash.bashrc`، `~/.bashrc`) وجود دارد. الگوهای کاربر جدید در `/etc/skel` ذخیره می‌شوند.

---

← 104.7 یافتن فایل‌های سیستم و قرار دادن فایل‌ها در مکان صحیح  
**فهرست فصل‌ها**  
105.2 شخصی‌سازی یا نوشتن اسکریپت‌های ساده →

**دسته‌بندی:** LPIC1  
**برچسب‌ها:** 102، LPIC1، LPIC1-102-500  
**تماس**
